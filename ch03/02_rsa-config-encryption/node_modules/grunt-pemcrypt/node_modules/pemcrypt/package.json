{
  "name": "pemcrypt",
  "description": "Read and write pem-encrypted JSON files",
  "author": {
    "name": "Nicolas Bevacqua",
    "email": "ng@bevacqua.io",
    "url": "http://bevacqua.io"
  },
  "version": "0.1.0",
  "repository": {
    "type": "git",
    "url": "git@github.com:bevacqua/node-pemcrypt.git"
  },
  "engines": {
    "node": ">=0.8"
  },
  "main": "pemcrypt.js",
  "dependencies": {
    "lodash": "1.3.1",
    "ursa": "0.8.0",
    "mkdirp": "~0.3.5"
  },
  "readme": "# Pemcrypt\n\nInstall with `npm`.\n\n```bash\n$ npm i pemcrypt --save\n```\n\nRequire. Show me some CommonJS/Modules love!\n\n```js\nvar pemcrypt = require('pemcrypt');\n```\n\n# Purpose\n\nThe goal of `pemcrypt` is to allow you to commit sensible environment configuration values in an encrypted manner to source control. All you need to do then, is get the private key originally used to encrypt a file, and you're good to go.\n\nIdeally, this would only be used for development configuration values. You would distribute a `.pemjson` file with your module, and give the private key to decrypt the file to your contributors. The upside is that you won't need to give them a new `.json` file every time a value needs to change, but rather just encrypt it again, and push the new `.pemjson`.\n\nMake sure you add `*.pem`, and whatever the decrypted JSON filename is to your `.gitignore`. Commiting either of those would defeat the entire purpose of this module.\n\n# #pemcrypt.generateKey\n\nGenerates a `.pem` file the first time around. You can save it wherever you won't, but **don't ever commit it to source control**.\n\n```js\npemcrypt.generateKey(pemfile);\n```\n\nThis method also returns the pem key right away if you want it for some reason.\n\n# #pemcrypt(options)\n\nCreates a pemcrypt `store` object. This will be used to `encrypt` and `decrypt` our files. This function will look for a `.pem` file and load it immediately, throwing if one isn't found.\n\n```js\nvar store = pemcrypt({\n    pem: pemfile,   // same one used to generate the key\n    cwd: __dirname  // defaults to process.cwd()\n});\n```\n\n# #store.encrypt(sourceStore, targetStore)\n\nEncrypts a raw `.json` file. This method will take a file path relative to `cwd`, _without the `.json` extension_. If `targetStore` equals `true`, the results are dumped to an encrypted `.pemjson` file next to the `.json` one. You can also pick a different name, if you want to keep secure and unsecure data in different places.\n\nThis method is _synchronous_ and returns the encrypted data, too.\n\n```js\nvar pemjson = store.encrypt('env/defaults');\n\nconsole.log(pemjson); // garbage\n\nstore.encrypt('env/defaults', true); // persisted to disk @ env/defaults.pemjson\nstore.encrypt('env/defaults', 'secure/defaults'); // persisted to disk @ secure/defaults.pemjson\n```\n\n# #store.decrypt(sourceStore, targetStore)\n\nDecrypts an encrypted `.pemjson` file. This method will take a file path relative to `cwd`, _without the `.pemjson` extension_. If `targetStore` equals `true`, the results are dumped to an encrypted `.pemjson` file next to the `.json` one. You can also pick a different name, if you want to keep secure and unsecure data in different places.\n\nThis method is _synchronous_ and returns the decrypted data, too.\n\n```js\nvar json = store.decrypt('env/defaults');\n\nconsole.log(json); // data!\n\nstore.decrypt('env/defaults', true); // persisted to disk @ env/defaults.json\nstore.decrypt('env/defaults', 'private/defaults'); // persisted to disk @ private/defaults.json\n```",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/bevacqua/node-pemcrypt/issues"
  },
  "_id": "pemcrypt@0.1.0",
  "_from": "pemcrypt@0.1.0"
}
